---
phase: 01-redis-scan-migration
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/rails_performance/utils.rb
autonomous: true

must_haves:
  truths:
    - "SCAN COUNT values validated on configuration (warn if > 10000)"
    - "Redis connection failures handled gracefully without crashes"
    - "SCAN operations have timeout protection (10-30 second range)"
    - "Error messages are minimal and logged via RailsPerformance.log"
    - "Existing error handling patterns in utils.rb are preserved"
  artifacts:
    - path: "lib/rails_performance/utils.rb"
      provides: "SCAN COUNT validation and error handling"
      contains: "validate_scan_count"
      contains: "handle_redis_error"
  key_links:
    - from: "lib/rails_performance/utils.rb"
      to: "RailsPerformance.log"
      via: "Error logging for SCAN failures"
      pattern: "RailsPerformance\.log.*\[SCAN"
    - from: "lib/rails_performance/utils.rb"
      to: "fetch_with_scan"
      via: "Error handling wrapper"
      pattern: "begin.*rescue"
---

<objective>
Add robust error handling and validation to the SCAN implementation to ensure production safety. This plan adds COUNT value validation (warning on extreme values), graceful degradation on Redis failures, timeout protection for SCAN operations, and minimal error logging following existing patterns.

Purpose: Ensure SCAN implementation fails gracefully in production and provides clear feedback for configuration issues while maintaining gem stability.

Output: SCAN COUNT validation method, error handling wrapper for SCAN operations, timeout configuration, and minimal error logging.
</objective>

<execution_context>
@/Users/itisbryan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/itisbryan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-redis-scan-migration/01-redis-scan-migration-CONTEXT.md
@.planning/phases/01-redis-scan-migration/01-redis-scan-migration-RESEARCH.md
@lib/rails_performance/utils.rb
@.planning/phases/01-redis-scan-migration/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add SCAN COUNT validation method</name>
  <files>lib/rails_performance/utils.rb</files>
  <action>
    Add validation method for SCAN COUNT values following research recommendations:

    1. After determine_scan_count method, add:
       ```ruby
       def self.validate_scan_count(count)
         if count < 1
           raise ArgumentError, "scan_count must be >= 1, got #{count}"
         end

         if count > 10_000
           RailsPerformance.log "[WARNING] scan_count (#{count}) is very high. This may cause long-running SCAN calls. Recommended range: 1-1000.\n"
         end
       end
       ```

    2. Modify fetch_with_scan to validate COUNT before SCAN:
       ```ruby
       def self.fetch_with_scan(query)
         count = determine_scan_count(query)
         validate_scan_count(count)

         keys = RailsPerformance.redis.scan_each(
           match: query,
           count: count
         ).to_a.sort

         keys
       end
       ```

    Per user decision: Warn if COUNT value is extreme (<1 or >10000).
    Per research: Use minimal error messages logged via RailsPerformance.log.
  </action>
  <verify>Run ruby -c lib/rails_performance/utils.rb and grep -A 5 "validate_scan_count" lib/rails_performance/utils.rb to verify validation logic exists</verify>
  <done>validate_scan_count method exists and is called in fetch_with_scan, raises on count < 1, warns on count > 10000</done>
</task>

<task type="auto">
  <name>Add error handling for SCAN operations</name>
  <files>lib/rails_performance/utils.rb</files>
  <action>
    Wrap SCAN operations in error handling following existing graceful degradation pattern:

    1. Modify fetch_with_scan to include error handling:
       ```ruby
       def self.fetch_with_scan(query)
         count = determine_scan_count(query)
         validate_scan_count(count)

         begin
           keys = RailsPerformance.redis.scan_each(
             match: query,
             count: count
           ).to_a.sort
         rescue Redis::BaseConnectionError => e
           RailsPerformance.log "[SCAN ERROR] Redis connection failed: #{e.message}\n"
           return []
         rescue Redis::CommandError => e
           RailsPerformance.log "[SCAN ERROR] Redis command failed: #{e.message}\n"
           return []
         rescue StandardError => e
           RailsPerformance.log "[SCAN ERROR] Unexpected error: #{e.message}\n"
           return []
         end

         keys
       end
       ```

    2. Ensure error messages are minimal per user discretion:
       - Format: "[SCAN ERROR] {brief description}: {error.message}"
       - No stack traces or verbose output
       - Return empty array on error (graceful degradation)

    Follow existing pattern: save_to_redis (line 43-50) shows basic error handling approach.
  </action>
  <verify>Grep -A 10 "def self.fetch_with_scan" lib/rails_performance/utils.rb and verify rescue blocks exist for Redis errors</verify>
  <done>fetch_with_scan has rescue blocks for Redis::BaseConnectionError, Redis::CommandError, and StandardError, returns empty array on error</done>
</task>

</tasks>

<verification>
Overall phase checks:
1. validate_scan_count raises ArgumentError for count < 1
2. validate_scan_count logs warning for count > 10000
3. fetch_with_scan calls validate_scan_count before SCAN
4. fetch_with_scan has rescue block for Redis::BaseConnectionError
5. fetch_with_scan has rescue block for Redis::CommandError
6. fetch_with_scan has rescue block for StandardError
7. All error messages use "[SCAN ERROR]" prefix
8. Error handling returns empty array (graceful degradation)
9. Error messages are minimal (no stack traces)
10. Code follows existing error handling patterns
</verification>

<success_criteria>
1. validate_scan_count method exists and validates COUNT >= 1
2. Warning logged when COUNT > 10000
3. fetch_with_scan wrapped in error handling
4. Redis connection failures caught and logged
5. Redis command failures caught and logged
6. Unexpected errors caught and logged
7. All error paths return empty array
8. Error messages use "[SCAN ERROR]" prefix
9. Error messages are minimal (message only, no stack traces)
10. Ruby syntax check passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-redis-scan-migration/01-02-SUMMARY.md` with:
- What validation and error handling was added
- Error message formats used
- How errors are handled (graceful degradation)
- Files modified
- Verification results
</output>
