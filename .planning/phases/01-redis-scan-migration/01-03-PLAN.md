---
phase: 01-redis-scan-migration
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - test/redis_scan_test.rb
autonomous: true

must_haves:
  truths:
    - "Test file exists with comprehensive SCAN vs KEYS comparison tests"
    - "Tests verify key pattern compatibility (all existing query types)"
    - "Tests verify sorted results match KEYS order"
    - "Tests verify feature flag toggles between SCAN and KEYS"
    - "Tests run successfully with redis gem"
  artifacts:
    - path: "test/redis_scan_test.rb"
      provides: "Integration tests for SCAN migration"
      min_lines: 100
      contains: "class RedisScanTest"
      contains: "test_scan_returns_sorted_keys"
      contains: "test_feature_flag_toggles_scan"
  key_links:
    - from: "test/redis_scan_test.rb"
      to: "lib/rails_performance/utils.rb"
      via: "require_relative '../lib/rails_performance/utils'"
      pattern: "require.*rails_performance/utils"
    - from: "test/redis_scan_test.rb"
      to: "Redis"
      via: "Test Redis connection setup"
      pattern: "Redis\.new"
---

<objective>
Create integration tests to verify SCAN implementation maintains full compatibility with existing KEYS behavior. These tests ensure all query patterns work correctly, results are sorted to match KEYS order, and the feature flag properly toggles between SCAN and KEYS implementations.

Purpose: Validate SCAN migration maintains backwards compatibility and works correctly with all existing key patterns before enabling in production.

Output: Comprehensive test file (redis_scan_test.rb) with tests for key pattern compatibility, sorting, feature flag toggling, and COUNT validation.
</objective>

<execution_context>
@/Users/itisbryan/.claude/get-shit-done/workflows/execute-plan.md
@/Users/itisbryan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-redis-scan-migration/01-redis-scan-migration-CONTEXT.md
@.planning/phases/01-redis-scan-migration/01-redis-scan-migration-RESEARCH.md
@lib/rails_performance/utils.rb
@lib/rails_performance/data_source.rb
@.planning/phases/01-redis-scan-migration/01-01-SUMMARY.md
@.planning/codebase/TESTING.md
</context>

<tasks>

<task type="auto">
  <name>Create integration test file for SCAN migration</name>
  <files>test/redis_scan_test.rb</files>
  <action>
    Create test/redis_scan_test.rb with comprehensive integration tests:

    1. Add test setup and teardown:
       ```ruby
       # frozen_string_literal: true

       require 'minitest/autorun'
       require 'redis'
       require_relative '../lib/rails_performance/utils'
       require_relative '../lib/rails_performance'

       class RedisScanTest < Minitest::Test
         def setup
           @redis = Redis.new
           @test_key_prefix = "performance|test|scan|#{Time.now.to_i}|"
           @redis.keys("#{@test_key_prefix}*").each { |k| @redis.del(k) }
           RailsPerformance.redis = @redis
         end

         def teardown
           @redis.keys("#{@test_key_prefix}*").each { |k| @redis.del(k) }
         end

         def create_test_keys(count, pattern_suffix = "")
           count.times do |i|
             key = "#{@test_key_prefix}#{i}#{pattern_suffix}"
             @redis.set(key, "value_#{i}")
           end
         end
       ```

    2. Add tests following existing test conventions from TESTING.md:
       ```ruby
         def test_scan_returns_sorted_keys
           create_test_keys(100)
           query = "#{@test_key_prefix}*"

           RailsPerformance.use_scan = true
           keys, values = RailsPerformance::Utils.fetch_from_redis(query)

           assert_equal 100, keys.size
           assert_equal keys, keys.sort, "SCAN results must be sorted to match KEYS behavior"
         end

         def test_keys_returns_sorted_keys
           create_test_keys(100)
           query = "#{@test_key_prefix}*"

           RailsPerformance.use_scan = false
           keys, values = RailsPerformance::Utils.fetch_from_redis(query)

           assert_equal 100, keys.size
           assert_equal keys, keys.sort, "KEYS results are sorted"
         end

         def test_feature_flag_toggles_scan
           create_test_keys(50)
           query = "#{@test_key_prefix}*"

           RailsPerformance.use_scan = true
           scan_keys, _ = RailsPerformance::Utils.fetch_from_redis(query)

           RailsPerformance.use_scan = false
           keys_keys, _ = RailsPerformance::Utils.fetch_from_redis(query)

           assert_equal scan_keys.sort, keys_keys.sort, "SCAN and KEYS return same keys"
         end

         def test_scan_with_datetime_pattern
           create_test_keys(50, "|datetime|20260204*")
           query = "#{@test_key_prefix}*datetime|20260204*|*"

           RailsPerformance.use_scan = true
           keys, values = RailsPerformance::Utils.fetch_from_redis(query)

           assert_operator keys.size, :>, 0, "SCAN should find datetime pattern keys"
           assert_equal keys, keys.sort, "SCAN results must be sorted"
         end

         def test_scan_with_controller_pattern
           create_test_keys(30, "|controller|HomeController|action|index")
           query = "#{@test_key_prefix}*controller|HomeController|action|index*"

           RailsPerformance.use_scan = true
           keys, values = RailsPerformance::Utils.fetch_from_redis(query)

           assert_operator keys.size, :>, 0, "SCAN should find controller pattern keys"
         end

         def test_scan_count_validation_raises_on_invalid_count
           RailsPerformance.use_scan = true
           RailsPerformance.scan_count = 0

           assert_raises(ArgumentError) do
             RailsPerformance::Utils.fetch_from_redis("#{@test_key_prefix}*")
           end
         end

         def test_scan_count_auto_tune_uses_correct_count
           RailsPerformance.use_scan = true
           RailsPerformance.scan_count_auto_tune = true

           # Test datetime query (should use 1000)
           count_datetime = RailsPerformance::Utils.send(:determine_scan_count, "performance|*|datetime|20260204*|*")
           assert_equal 1000, count_datetime

           # Test specific request query (should use 10)
           count_request = RailsPerformance::Utils.send(:determine_scan_count, "performance|*|request_id|xyz|*")
           assert_equal 10, count_request

           # Test broad query (should use 100)
           count_broad = RailsPerformance::Utils.send(:determine_scan_count, "performance|*controller|*")
           assert_equal 100, count_broad
         end

         def test_scan_handles_empty_results
           query = "#{@test_key_prefix}nonexistent*"

           RailsPerformance.use_scan = true
           keys, values = RailsPerformance::Utils.fetch_from_redis(query)

           assert_equal 0, keys.size
           assert_equal 0, values.size
         end

         def test_scan_with_large_dataset
           create_test_keys(1000)
           query = "#{@test_key_prefix}*"

           RailsPerformance.use_scan = true
           keys, values = RailsPerformance::Utils.fetch_from_redis(query)

           assert_equal 1000, keys.size
           assert_equal keys, keys.sort
         end
       end
       ```

    Follow existing test conventions from TESTING.md:
    - Use Minitest::Test as base class
    - Use setup/teardown blocks
    - Use assert_equal, assert_operator, assert_raises assertions
    - Test method names prefixed with test_
  </action>
  <verify>Run ruby -c test/redis_scan_test.rb to check syntax, then run rake test TEST=test/redis_scan_test.rb to verify tests pass</verify>
  <done>Test file exists, syntax check passes, all 10 tests pass successfully</done>
</task>

</tasks>

<verification>
Overall phase checks:
1. test/redis_scan_test.rb file exists
2. Test class inherits from Minitest::Test
3. setup method creates Redis connection and clears test keys
4. teardown method cleans up test keys
5. test_scan_returns_sorted_keys verifies sorting
6. test_keys_returns_sorted_keys verifies KEYS baseline
7. test_feature_flag_toggles_scan verifies flag works
8. test_scan_with_datetime_pattern tests date-scoped queries
9. test_scan_with_controller_pattern tests controller queries
10. test_scan_count_validation_raises_on_invalid_count tests validation
11. test_scan_count_auto_tune_uses_correct_count tests auto-tuning
12. test_scan_handles_empty_results tests empty results
13. test_scan_with_large_dataset tests 1000 key dataset
14. All tests use RailsPerformance.use_scan to toggle behavior
15. All tests use create_test_keys helper
</verification>

<success_criteria>
1. Test file created at test/redis_scan_test.rb
2. Test class RedisScanTest inherits from Minitest::Test
3. setup/teardown methods for Redis lifecycle
4. create_test_keys helper method
5. 10+ test methods covering all SCAN functionality
6. Tests verify sorted results match KEYS order
7. Tests verify feature flag toggles between SCAN and KEYS
8. Tests verify all query patterns (datetime, controller, etc.)
9. Tests verify COUNT validation
10. Tests verify auto-tuning logic
11. Tests handle empty results gracefully
12. Tests work with 1000+ key datasets
13. All tests pass when run
14. Code follows existing test conventions
15. Ruby syntax check passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-redis-scan-migration/01-03-SUMMARY.md` with:
- Test coverage summary
- All test cases created
- Test results (pass/fail)
- Any edge cases discovered
- Files modified
</output>
